<!DOCTYPE html>
<html lang="en-us">
<head>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-66704504-1', 'auto');
        ga('send', 'pageview');

    </script>
    <meta charset="UTF-8">
    <title>ScaleCube Cluster</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
</head>
<body onload="prettyPrint()">

<section class="page-header" style="margin:0">
    <h1 class="project-name" style="padding-top: 25px;">ScaleCube Cluster</h1>
    <a href="https://github.com/scalecube" class="btn">View on GitHub</a>
    <a href="https://github.com/scalecube/scalecube/zipball/master" class="btn">Download .zip</a>
    <a href="https://github.com/scalecube/scalecube/tarball/master" class="btn">Download .tar.gz</a>
</section>

<div class="main-content">
    <section class="col-xs-7 col-sm-8 col-md-10">
        <h2>Intro</h2>
        <p>ScaleCube Cluster provides a fault-tolerant decentralized peer-to-peer based cluster membership service with no single point of failure or single point of bottleneck.
            It does this using gossip protocols and an automatic failure detector.
        </p>

        <h2>Terms</h2>
        <h4>Cluster Member</h4>
        <p>A logical member of a cluster. There could be multiple nodes on a physical machine. Defined by a member id.</p>

        <h4>Cluster</h4>
        <p>A set of nodes joined together through the membership service.</p>

        <h4>Seed Members</h4>
        <p>
            The seed members are configured contact points for new members joining the cluster.
            When a new member is started it sends to all seed nodes (one by one) sync command in order to synchronize membership tables until one of them answers,
            if all failed to answer it is decided that this member is the first member in the cluster.
            Seed members will be used further in order to restore cluster from network partitioning They will continued to be and sync with cluster nodes even if they are marked as failed.
            So it is possible to configure any node as seed member in order to join the cluster, but it is recommended to configure nodes with most probability for maximum up-time
            so in such case they can restore from network partitioning via this seed members (e.g. possible choice for seed members are API Gateways)
            The seed members configuration does not have any influence on the running cluster itself,
            it is only relevant for new members joining the cluster as it helps them to find contact points to send the join command to;
            a new member can send this command to any current member of the cluster, not only to the seed members.
            The seed nodes can be started in any order and it is not necessary to have all/or any seed nodes running, but when initially starting a cluster,
            the cluster will be initialized only when one or more seed-nodes will become initialized else no other node can join the cluster and nodes can only join themselves.
            It is quickest to start all configured seed nodes at the same time (order doesn't matter), otherwise it can take up to time until the nodes can join.
            Once more than two seed nodes have been started it is no problem to shut down the first seed node.
            If the first seed node is restarted, it will first try to join the other seed nodes in the existing cluster.
            You can join to any node in the cluster. It does not have to be configured as a seed node.
            Note that you can only join to an existing cluster member, which means that for bootstrapping some node must join itself,and then the following nodes could join them to make up a cluster.
        </p>

        <h4>Failure Detector</h4>
        <p>The failure detector is responsible for trying to detect if a node is unreachable from the rest of the cluster
            In a cluster each node is monitored by a few (default maximum 5) other nodes,
            and when any of these detects the node as unreachable that information will spread to the rest of the cluster through the gossip.In other words,
            only one node needs to mark a node unreachable to have the rest of the cluster mark that node unreachable.
            The failure detector will also detect if the node becomes reachable again.
            When all nodes that monitored the unreachable node detects it as reachable again the cluster, after gossip dissemination, will consider it as reachable.
            If a messages cannot be delivered to a node it will be quarantined and then it cannot come back from unreachable.
            The nodes in the cluster monitor each other by sending heartbeats to detect if a node is unreachable from the rest of the cluster.
            once a node becomes reachable again it can try and rejoin the cluster.
            The heartbeat arrival times is interpreted by an implementation of The Phi Accrual Failure Detector.
            The suspicion level of failure is given by a value called phi. The basic idea of the phi failure detector is to express the value of phi on a scale that is dynamically adjusted to reflect current network conditions
        </p>

        <h4>Preparing Your Project for Clustering</h4>

        <p>The ScaleCube Cluster is a separate jar file. Make sure that you have the following dependency in your project:</p>

        <pre class="prettyprint">

    &lt;dependency&gt;
        &lt;groupId&gt;io.servicefabric&lt;/groupId&gt;
        &lt;artifactId&gt;servicefabric-cluster&lt;artifactId&gt;
        &lt;version&gt;${project.version}&lt;version&gt;
    &lt;/dependency&gt;
        </pre>

        <h3>Simple Cluster examples</h3>

        <p>Setting up cluster nodes A and B while A is seed node and B use A as seed:</p>

	    <pre class="prettyprint">

    // create cluster member A on port 3000 and join as seed member
    ICluster clusterA = Cluster.newInstance(3000).join();

    // create cluster member B on port 3001 and join as seed member A
    ICluster clusterB =  Cluster.newInstance(3001,"localhost:3000").join();
        </pre>

        <h4>Send gossip from member-A that eventually will reach all members</h4>

        <p>Subscribe to gossip:</p>

	    <pre class="prettyprint">

    // subscribe to all gossip messages:
    clusterA.gossip().listen().subscribe(new Action1&lt;Message&gt;() {
        @Override
        public void call(Message gossip) {
            // print out the gossip message
            System.out.println("Gossip message:"  + gossip);
        }
    });
        </pre>

        <p>Spread gossip from member-B:</p>

	    <pre class="prettyprint">

    // spread gossip
    clusterB.gossip().spread(new Message(new Greetings("Greetings from ClusterMember B")));
        </pre>

        <h4>Send message from member-B to member-A</h4>

        <p>Subscribe to Greetings message on member-A using filter:</p>

        <pre class="prettyprint">

    // Filter and subscribe to greetings messages:
    clusterA.listen().filter(new Func1&lt;TransportMessage, Boolean&gt;() {
        @Override
        public Boolean call(TransportMessage t1) {
            return t1.message().data() != null && Greetings.class.equals(t1.message().data().getClass());
        }
    }).subscribe(new Action1&lt;TransportMessage&gt;() {
            @Override
            public void call(TransportMessage t1) {
            System.out.println(t1.message().data());
        }
    });
        </pre>

        <p>Send Greetings message to member-A:</p>

	    <pre class="prettyprint">

    // Send greeting message to other cluster members
    List&lt;ClusterMember&gt; members = clusterB.membership().members();

    for (ClusterMember member : members) {
        if (!clusterB.membership().isLocalMember(member)) {
            clusterB.to(member).send(new Message(new Greetings("Greetings from ClusterMember B")));
        }
    }
        </pre>
    </section>

    <section class="col-xs-5 col-sm-4 col-md-2">
        <a class="twitter-timeline" href="https://twitter.com/ScaleCube" data-widget-id="634655010568060928">Tweets by @ScaleCube</a>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    </section>
</div>

</body>
</html>

